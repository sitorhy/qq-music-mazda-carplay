const test = `[ti:アイスクリーム シンドローム (冰淇淋症候群) (Movie edition)]
[ar:スキマスイッチ (无限开关)]
[al:劇場版ポケットモンスター ダイヤモンド・パール「幻影の覇者 ゾロアーク」ミュージックコレクション (宠物小精灵剧场版-幻影的霸者索罗亚克原声集)]        
[by:]
[offset:0]
[00:00.00]アイスクリーム シンドローム (Movie edition) - 无限开关 (スキマスイッチ)
[00:00.36]词：スキマスイッチ
[00:00.72]曲：スキマスイッチ
[00:01.08]関係はいたってフラットだ
[00:03.08]何でも話せるくらいかな
[00:05.17]付き合いは長いが
[00:06.71]何も変わらないよな
[00:09.29]せっかく用意したムードも
[00:11.51]茶化されて
[00:12.14]終わってしまうんだよ
[00:13.64]打ち明けられないまま
[00:15.20]カッコもつかないまま
[00:17.04]
[00:35.06]太陽は暑く照っている
[00:36.96]Tシャツが汗ばんでいる
[00:39.01]ジメッとした僕みたい
[00:40.63]いつまでも乾かないや
[00:43.37]逃げ込んで入ったコンビニ
[00:45.44]懐かしいコミックを購入
[00:47.63]君がいればどうかな
[00:49.19]一緒に笑えるかな
[00:51.12]
[01:08.92]もう何年演じているんだろう
[01:11.02]親友としてのキャスティング
[01:13.08]距離感はいいんだが
[01:14.69]でも本音を言えばツライや
[01:17.22]相談しやすいっていうけど
[01:19.42]いつも君の恋愛トーク
[01:21.65]微妙な心の中
[01:23.20]バレないようにして
[01:24.40]この目の奥に映っている笑顔を
[01:29.16]僕だけのモノにしたいんだ
[01:33.23]
[01:33.90]どうにか
[01:35.60]焼き付けられないかな
[01:41.01]
[01:41.78]そっとファインダーを
[01:44.30]覗いたら
[01:46.23]
[01:47.19]想像よりずっとずっと
[01:49.45]遠くに君がいる気がした
[01:54.23]いつかは誰かと
[02:00.30]消えていってしまう
[02:03.16]
[02:04.16]見上げれば
[02:05.62]青い空真っ二つに
[02:08.86]割ってくジェット機
[02:11.22]遥か空へ
[02:15.51]夏が飛んでいく
[02:17.03]
[02:19.74]季節がもう
[02:24.11]過ぎていく
[02:25.44]
[02:29.81]陽炎の中で立っている
[02:31.64]不器用なだけのボンクラ
[02:33.75]ぼやけている世界でも
[02:35.40]君だけは歪まないや
[02:37.98]友情って名前のシンドローム
[02:40.13]出口のない永久迷路
[02:42.28]動くのも怖いから
[02:43.92]踏み出せないでいる
[02:45.18]食べようとしていたはずの
[02:48.18]アイスクリーム
[02:49.84]ベタベタに溶けていたんだ
[02:53.93]
[02:54.81]運命って
[02:56.63]待ってくれないんだなぁ
[03:01.29]
[03:02.43]今会いたいすぐにでも
[03:06.99]
[03:07.96]いつになくマジメな声で
[03:10.96]誘い出してみようかな
[03:14.86]そのまま
[03:18.82]
[03:19.68]連れ去ってしまえたならもう
[03:23.85]
[03:24.82]勢いで抱え込んだ
[03:27.72]想いも伝えられるかも
[03:31.93]
[03:32.73]あぁ
[03:35.67]
[03:36.55]そうファインダーを
[03:38.99]覗いたら
[03:40.81]
[03:41.85]手が届きそうなほど
[03:44.02]そばに君が
[03:45.95]見えたらいいな
[03:48.76]幸せは増えたって
[03:55.01]減るもんじゃない
[03:57.79]
[03:58.87]君となら
[04:00.19]どんな一瞬だって
[04:02.82]煌めいてみえる
[ti:]
[ar:スキマスイッチ (无限开关)]
[al:劇場版ポケットモンスター ダイヤモンド・パール「幻影の覇者 ゾロアーク」ミュージックコレクション (宠物小精灵剧场版-幻影的霸者索罗亚克原声集)]        
[by:]
[offset:0]
[00:00.00]//
[00:00.36]//
[00:00.72]//
[00:01.08]我们的关系非常平缓
[00:03.08]算是无话不谈的程度吧
[00:05.17]虽然认识了很久
[00:06.71]却没有任何变化
[00:09.29]好不容易营造的气氛
[00:11.51]也被你搪塞过去
[00:12.14]不了了之
[00:13.64]始终无法向你表白
[00:15.20]始终表现不出帅气的一面
[00:17.03]
[00:35.06]酷热的太阳照射着
[00:36.96]T恤上全是汗
[00:39.01]就像湿漉漉的我
[00:40.63]永远也干不了
[00:43.37]逃进便利店
[00:45.43]买了让人怀念的漫画
[00:47.63]如果你在的话会怎么样呢
[00:49.19]会和我一起欢笑吗
[00:51.12]
[01:08.92]已经扮演好多年了吧
[01:11.02]作为挚友的角色
[01:13.08]距离感是很好
[01:14.69]可老实说真的很难受
[01:17.22]虽说和你交谈很容易
[01:19.42]但总是在谈你的恋爱史
[01:21.65]微妙的心理
[01:23.19]但愿不要被你发现
[01:24.40]好想将我眼眸深处映出的笑容
[01:29.16]据为己有
[01:33.23]
[01:33.90]没办法
[01:35.60]将它冲洗出来吗
[01:41.01]
[01:41.78]轻轻地窥视
[01:44.30]取景器
[01:46.23]
[01:47.19]感觉你就存在于
[01:49.45]比我想象更遥远的地方
[01:54.23]总有一天会
[02:00.30]和某个人一起消失吧
[02:03.16]
[02:04.16]抬头望去
[02:05.62]喷气机将蓝天
[02:08.86]分割成了两半
[02:11.22]夏日
[02:15.51]飞向遥远天空
[02:17.03]
[02:19.74]季节已经
[02:24.11]渐渐逝去
[02:25.44]
[02:29.81]阳炎中笨拙的傻子
[02:31.64]就这么呆呆地站着
[02:33.75]模糊的世界
[02:35.40]只有你不会扭曲
[02:37.97]名为友情的症候群
[02:40.13]没有出口的永恒迷宫
[02:42.28]连动一下都害怕
[02:43.92]更不敢踏出一步
[02:45.18]原本打算吃掉的
[02:48.17]冰淇淋
[02:49.84]粘粘糊糊地融化了
[02:53.93]
[02:54.80]命运
[02:56.63]是不等人的
[03:01.28]
[03:02.43]现在好想马上见到你
[03:06.99]
[03:07.96]用一反常态的认真语气
[03:10.96]约你出来吧
[03:14.86]如果就这样
[03:18.82]
[03:19.68]将你带走的话
[03:23.85]
[03:24.82]也许就能顺势
[03:27.72]将心中的想法传达给你
[03:31.93]
[03:32.73]啊
[03:35.67]
[03:36.55]就这样窥视
[03:38.99]取景器
[03:40.81]
[03:41.85]如果在触手可及的地方
[03:44.02]能够看得到你
[03:45.95]该有多好啊
[03:48.76]幸福只会增加
[03:55.01]不会减少
[03:57.78]
[03:58.87]只要和你一起
[04:00.19]怎样的瞬间
[04:02.82]都闪耀无比
[04:05.76]`;

export function parseLyric(lyricText = "") {
    const data = [];
    const lines = lyricText.split("\n").filter(i => !!i);
    lines.map((line) => {
        const matchs = line.match(/\[\d+:\d+\.?\d+]/);
        if (matchs && matchs.length) {
            const m = matchs[0].toString();
            const lineText = line.substring(m.length);
            let index = 0;
            data.push({
                timestamp: m.substring(1, m.length - 1).split(':').map(n => Number.parseFloat(n)).reverse().reduce((s, i) => {
                    return s + i * Math.pow(60, index++);
                }, 0),
                content: lineText,
                tagText: m,
                type: 'time'
            });
        } else {
            const matchs = line.match(/\[(.*):/);
            if (matchs && matchs.length) {
                const content = line.substring(line.indexOf(':') + 1, line.lastIndexOf(']'));
                data.push({
                    type: matchs[1],
                    content: content.trim(),
                    tagText: line.trim()
                });
            }
        }
    });
    return data;
}

export function joinLyricData(data) {
    const copy = [...data];
    for (let i = 0; i < copy.length; ++i) {
        const obj = copy[i];
        if (obj) {
            for (let j = i + 1; j < copy.length; ++j) {
                const obj2 = copy[j];
                if (obj2 != null) {
                    if (obj2.type === 'time') {
                        if (obj2.tagText === obj.tagText) {
                            obj.contents = []
                                .concat(obj.contents ? obj.contents : obj.content)
                                .concat(obj2.contents ? obj2.contents : obj2.content);
                            copy[j] = null;
                        }
                    } else {
                        if (obj2.type === obj.type) {
                            obj.contents = []
                                .concat(obj.contents ? obj.contents : obj.content)
                                .concat(obj2.contents ? obj2.contents : obj2.content);
                            copy[j] = null;
                        }
                    }
                }
            }
        }
    }
    const joined = copy.filter(i => !!i);
    joined.sort((a, b) => {
        const pa = a.type === 'time' ? a.timestamp : -1;
        const pb = b.type === 'time' ? b.timestamp : -1;
        return pa - pb;
    }).forEach((i) => {
        if (i.contents) {
            i.contents = i.contents.filter((j) => !!j && j !== '//');
            if (i.type !== 'time') {
                i.contents = i.contents.slice(0, 1);
            }
        }
    });
    return joined;
}

export function toText(joinedData) {
    const text = [];
    joinedData.forEach(i => {
        if (i.contents) {
            i.contents.forEach(j => {
                text.push(i.type === 'time' ? `${i.tagText}${j}` : `[${i.type}: ${j}]`);
            });
        } else {
            text.push(i.type === 'time' ? `${i.tagText}${i.content}` : `[${i.type}: ${i.content}]`);
        }
    });

    return text.join('\n');
}

const data = parseLyric(test);
const joinedData = joinLyricData(data);
console.log(toText(joinedData));